---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

```{r}
library(JuliaCall)

```

```{r}
exp_cdf <- function(x, lambda){
  1 - exp(-lambda * x)
}

# double check to make sure our reinvention is correct
exp_cdf(x=2, lambda=2)
pexp(q=2, rate=2)

# this is what the exponential cdf looks like
plot(seq(0,3,.1), exp_cdf(seq(0,3,.1), lambda=2))

# transform exponential cdf to make more numerically stable
exp_l_cdf <- function(x, lambda){
  log1p( - exp(-lambda * x))
}

# now integrate the density numerically
exp_l_cdf2 <- function(x1, lambda1) {
  
  # return the log cdf
  log(integrate(dexp, rate = lambda1, lower = 0, upper = x1)$value)
}

# now make function to simulate draws from exponential distribution
simtime <- function(par, method = "analytic"){
  # sample between 0 and 1
  usamp <- runif(n=1, 0, 1)
  
  # objective function
  if(method == "analytic") {
    x_obj_fun <- function(x, u=usamp, lambda=par){
      exp_l_cdf(x, lambda) - log(u)
    }
  } else {
    x_obj_fun <- function(x, u=usamp, lambda=par){
      exp_l_cdf2(x, lambda) - log(u)
    }
  }
  
  # SOLVE!
  uniroot(f=x_obj_fun, interval=c(0,10))$root
}


# sanity check
simulated_data <- replicate(10000, simtime(par=2, method = "numeric"))

hist(simulated_data, freq = FALSE, breaks=50)

lines(seq(0,4,0.01), dexp(seq(0,4,0.01), rate = 2), col="red")


# another sanity check
simulated_correct_data <- rexp(10000, rate=2)
hist(simulated_correct_data, freq = FALSE, breaks=seq(0,10,0.1), col="red", add=TRUE)
```

```{julia}

using Random, Distributions

function exp_cdf_J(x, lambda)
  y = 1 - exp(-lambda * x)
  return(y)
end
```

```{julia}
# double check to make sure our reinvention is correct
# scale(d)           # Get the scale parameter, i.e. θ (theta)
# rate(d)            # Get the rate parameter, i.e. 1 / θ
#in distributions package - Exponential takes the scale, so to be equivalent with base::pexp(rate) and our specifications use 1 / theta

exp_cdf_J(2, 2)
cdf(Exponential(2), 2) #scale
cdf(Exponential(1/2), 2) #rate
```
```{r}
#R and JUlia behaving the same
pexp(q=2, rate=2)
```

```{julia}
# this is what the exponential cdf looks like (in Julia)
using Plots
a = collect(0:.1:3)
d = []
for i in a
  push!(d, exp_cdf_J(i,2))
end

using Plots
plot(a,d, seriestype= :scatter, label = "Wheel ExpCDF")
plot!(a,cdf(Exponential(1/2), a), seriestype = :line, color = :green, label = "package ExpCDF")
```

```{r}
#numerically stable
# transform exponential cdf to make more numerically stable

a <- seq(0,3,.1)
l <- 2

exp_l_cdf <- function(x, lambda){
  log1p( - exp(-lambda * x))
}

exp_cdf <- function(x, lambda){
  1 - exp(-lambda * x)
}

exp(exp_l_cdf(a,l)) - exp_cdf(a,l)

```
```{julia}

#numerically stable Julia
#https://tamaspapp.eu/post/log1p/

function expCdf_Jstable(x, lambda)
  y = log1p(- exp(-lambda * x))
  return(y)
end

a = expCdf_Jstable(2,2)
exp(a)
exp_cdf_J(2,2)

```


```{r}
# now integrate the density numerically
expCdf_Rstable2 <- function(x1, lambda1) {
  
  # return the log cdf from the probability density function
  log(integrate(dexp, rate = lambda1, lower = 0, upper = x1)$value)
}

exp(expCdf_Rstable2(2,2))
pexp(2,2)
```

```{julia}
#Pkg.add("QuadGK")
using QuadGK
#equation for pdf returns the cdf
integral, err = quadgk(x -> (2*exp(-2 * x)), 0, 2)
cdf(Exponential(1/2), 2)

```

```{julia}
# in a formula
function logCDF_integral(x, lambda)
  integral, err = quadgk(x -> (lambda*exp(-lambda * x)), 0, 2)
  return(log(integral))
end

a=logCDF_integral(2,2)
exp(a)
```
```{julia}
#Pkg.add("Roots")
using Roots

f(x) = exp(x) - x^4
a=find_zero(f, (-10, 0))
f(a)
```


```{julia}

#making find_zero recognize lambda and u
#here's a similar suggestion from stack overflow:
#https://stackoverflow.com/questions/53824498/finding-univariate-roots-in-julia-of-a-function-with-many-arguments

function a_1(x)
  3 + x
end

find_zero(a_1, 1)

###this works nested
function a_2_root(y)
    function a_3(x)
        x + y
    end
    find_zero(a_3, 1)
end

a_2_root(10)

### this works using an anonymous function
function a_3_root(y)
    u = rand(1)
    a_3(x) = x + y + u[1]
    find_zero(a_3, 1)
end

a_3_root(1)
```



```{julia}
#  function x_numerical(lambda)
#    u = rand(1)
#    #a_3(x) = logCDF_integral(x, lambda) -log(u[1])
#    #a_3(x) = x + lambda + u[1]
#    #a_3(x) = quadgk(x -> (lambda*exp(-lambda * x)), 0, 2)
#    #find_zero(a_3, 3)
#    end
#           
# x_numerical(2)
```

```{r}
exp_l_cdf <- function(x, lambda){
  log1p( - exp(-lambda * x))
}

# now integrate the density numerically
exp_l_cdf2 <- function(x1, lambda1) {
  
  # return the log cdf
  log(integrate(dexp, rate = lambda1, lower = 0, upper = x1)$value)
}
```

```{julia}
# u = rand(1)
# log(cdf(Exponential(1/2),2)) - log(u[1])

f3(x)= log(quadgk(x -> (2*exp(-2 * x)), 0, 2)[1])
a=f3(10)
typeof(a)
typeof(f3)
find_zero(f3,(0,10))

```


```{julia}


function solver(method, lambda)
  u = rand(1)
    if method == "prebuilt"
      f1(x) = (log(cdf(Exponential(1/lambda),x))) - log(u[1])
      find_zero(f1,(0,10))
     elseif method == "analytic"
       f2(x) = (log1p(-exp(-lambda * x))) -log(u[1])
       find_zero(f2,(0,10))
    else
      f3(x)= quadgk(x -> (lambda*exp(-lambda * x)), 0, 2)[1]
      find_zero(f3,(0,10))
      end
end

solver("prebuilt",2)
solver("analytic",2)
#solver("other", 2)
```

```{julia}
f1(x) = (pdf(Exponential(1/2),x))

f1(2)
find_zero(f1, 1)

```


```{r}
# now make function to simulate draws from exponential distribution
simtime <- function(par, method = "analytic"){
  #randomly sample from a uniform distribution between 0 and 1 - this value will change
  #every replication downstream
  usamp <- runif(n=1, 0, 1)
  
  # objective function
  if(method == "analytic") {
    x_obj_fun <- function(x, u=usamp, lambda=par){
      exp_l_cdf(x, lambda) - log(u) #define function for uniroot to explore
    }
  } else {
    x_obj_fun <- function(x, u=usamp, lambda=par){
      exp_l_cdf2(x, lambda) - log(u) #numerically for when cdf function is not known
    }
  }
  
  # SOLVE!
  uniroot(f=x_obj_fun, interval=c(0,10))$root #this step finds the inverse cdf - for when can't code in the analytic function for i_cdf
}

```

```{r}
# sanity check
set.seed(123)
simulated_data <- replicate(100, simtime(par=2, method = "numeric"))
hist(simulated_data, freq = FALSE, breaks=50)


lines(seq(0,4,0.01), dexp(seq(0,4,0.01), rate = 2), col="red")


# another sanity check
simulated_correct_data <- rexp(100, rate=2)
hist(simulated_correct_data, freq = FALSE, breaks=seq(0,10,0.1), col="red", add=TRUE)

```

